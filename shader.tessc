#version 440 core

layout (vertices = 4) out;

patch out highp vec3 normal;
patch out highp mat3 tbn;
out highp vec2[] tc;

uniform mat4 modelToWorld;
uniform mat4 worldToCamera;
uniform mat4 cameraToView;

float lenght(vec2 a)
{
    float temp = a.x * a.x + a.y * a.y;
    return sqrt(temp);
}

void main(void)
{
    mat4 mvp = cameraToView * worldToCamera * modelToWorld;
    const vec2 tc[] = const vec2[] (
        vec2(1.0, 1.0),
        vec2(0.0, 1.0),
        vec2(0.0, 0.0),
        vec2(1.0, 0.0)
    );
    vec2 uv1 = tc[1] - tc[0];
    vec2 uv2 = tc[3] - tc[0];
    vec3 e1 = gl_in[1].gl_Position.xyz - gl_in[0].gl_Position.xyz;
    vec3 e2 = gl_in[3].gl_Position.xyz - gl_in[0].gl_Position.xyz;
    if(gl_InvocationID == 0)
    {
        vec4 p0 = mvp * gl_in[0].gl_Position;
        vec4 p1 = mvp * gl_in[1].gl_Position;
        vec4 p2 = mvp * gl_in[2].gl_Position;
        vec4 p3 = mvp * gl_in[3].gl_Position;
        p0 /= p0.w;
        p1 /= p1.w;
        p2 /= p2.w;
        p3 /= p3.w;
        float l0 = length(p2.xy - p0.xy) * 16.0 + 1.0;
        float l1 = length(p3.xy - p2.xy) * 16.0 + 1.0;
        float l2 = length(p3.xy - p1.xy) * 16.0 + 1.0;
        float l3 = length(p1.xy - p0.xy) * 16.0 + 1.0;
        gl_TessLevelOuter[0] = l0;
        gl_TessLevelOuter[1] = l1;
        gl_TessLevelOuter[2] = l2;
        gl_TessLevelOuter[3] = l3;
        gl_TessLevelInner[0] = min(l1, l3);
        gl_TessLevelInner[1] = min(l0, l2);
    }
    gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;
    normal = cross(e1, e2);
    float r = 1 / ((uv1.x * uv2.y) - (uv1.y - uv2.x));
    vec3 tangent = (e1 * uv2.y - e2 * uv1.y) * r;
    tangent = normalize(tangent);
    tangent = normalize(tangent - dot(tangent, normal) * normal);
    vec3 bitangent = cross(tangent, normal);
    if(dot(cross(normal, tangent), bitangent) < 0.0)
        tangent = tangent * (-1.0);
    tbn = mat3(tangent, bitangent, normal);
}















