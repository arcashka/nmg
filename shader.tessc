#version 440 core

layout (vertices = 4) out;

patch out highp vec3 normal;
patch out vec2 tc[4];

uniform mat4 modelToWorld;
uniform mat4 worldToCamera;
uniform mat4 cameraToView;

float lenght(vec2 a)
{
    float temp = a.x * a.x + a.y * a.y;
    return sqrt(temp);
}

void main(void)
{
    mat4 mvp = cameraToView * worldToCamera * modelToWorld;

    tc[0] = vec2(1.0, 1.0);
    tc[1] = vec2(0.0, 1.0);
    tc[2] = vec2(1.0, 0.0);
    tc[3] = vec2(0.0, 0.0);

    vec2 uv1 = tc[1] - tc[0];
    vec2 uv2 = tc[3] - tc[0];
    vec3 e1 = gl_in[1].gl_Position.xyz - gl_in[0].gl_Position.xyz;
    vec3 e2 = gl_in[2].gl_Position.xyz - gl_in[1].gl_Position.xyz;
    if(gl_InvocationID == 0)
    {
        gl_TessLevelOuter[0] = 30;
        gl_TessLevelOuter[1] = 30;
        gl_TessLevelOuter[2] = 30;
        gl_TessLevelOuter[3] = 30;
        gl_TessLevelInner[0] = 30;
        gl_TessLevelInner[1] = 30;
    }
    gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;
    tscOut[gl_InvocationID].normal = normall[gl_InvocationID];//tscIn[gl_InvocationID].normal;
    normal = cross(e1, e2);

    // всё таки вычисление ТБН до того, как треугольник повернут - плохая идея
    // этому всему лучше бы переехать в геометрический шейдер
    float r = 1 / ((uv1.x * uv2.y) - (uv1.y - uv2.x));
    vec3 tangent = (e1 * uv2.y - e2 * uv1.y) * r;
    tangent = normalize(tangent);
    tangent = normalize(tangent - dot(tangent, normal) * normal);
    vec3 bitangent = cross(tangent, normal);
    if(dot(cross(normal, tangent), bitangent) < 0.0)
        tangent = tangent * (-1.0);
    //tbn = mat3(tangent, bitangent, normal);
}















